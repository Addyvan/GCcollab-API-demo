/**
 * This file was automatically generated by nexus-prisma@0.3.7
 * Do not make changes to this file directly
 */

import { core } from 'nexus'
import { GraphQLResolveInfo } from 'graphql'
import * as prisma from '../prisma-client'

declare global {
  interface NexusPrismaGen extends NexusPrismaTypes {}
}

export interface NexusPrismaTypes {
  objectTypes: {
    fields: {
      Query: QueryObject
      User: UserObject
      Group: GroupObject
      Discussion: DiscussionObject
      Comment: CommentObject
      UserConnection: UserConnectionObject
      PageInfo: PageInfoObject
      UserEdge: UserEdgeObject
      AggregateUser: AggregateUserObject
      GroupConnection: GroupConnectionObject
      GroupEdge: GroupEdgeObject
      AggregateGroup: AggregateGroupObject
      DiscussionConnection: DiscussionConnectionObject
      DiscussionEdge: DiscussionEdgeObject
      AggregateDiscussion: AggregateDiscussionObject
      CommentConnection: CommentConnectionObject
      CommentEdge: CommentEdgeObject
      AggregateComment: AggregateCommentObject
      Mutation: MutationObject
      BatchPayload: BatchPayloadObject
      Subscription: SubscriptionObject
      UserSubscriptionPayload: UserSubscriptionPayloadObject
      UserPreviousValues: UserPreviousValuesObject
      GroupSubscriptionPayload: GroupSubscriptionPayloadObject
      GroupPreviousValues: GroupPreviousValuesObject
      DiscussionSubscriptionPayload: DiscussionSubscriptionPayloadObject
      DiscussionPreviousValues: DiscussionPreviousValuesObject
      CommentSubscriptionPayload: CommentSubscriptionPayloadObject
      CommentPreviousValues: CommentPreviousValuesObject
    }
    fieldsDetails: {
      Query: QueryFieldDetails
      User: UserFieldDetails
      Group: GroupFieldDetails
      Discussion: DiscussionFieldDetails
      Comment: CommentFieldDetails
      UserConnection: UserConnectionFieldDetails
      PageInfo: PageInfoFieldDetails
      UserEdge: UserEdgeFieldDetails
      AggregateUser: AggregateUserFieldDetails
      GroupConnection: GroupConnectionFieldDetails
      GroupEdge: GroupEdgeFieldDetails
      AggregateGroup: AggregateGroupFieldDetails
      DiscussionConnection: DiscussionConnectionFieldDetails
      DiscussionEdge: DiscussionEdgeFieldDetails
      AggregateDiscussion: AggregateDiscussionFieldDetails
      CommentConnection: CommentConnectionFieldDetails
      CommentEdge: CommentEdgeFieldDetails
      AggregateComment: AggregateCommentFieldDetails
      Mutation: MutationFieldDetails
      BatchPayload: BatchPayloadFieldDetails
      Subscription: SubscriptionFieldDetails
      UserSubscriptionPayload: UserSubscriptionPayloadFieldDetails
      UserPreviousValues: UserPreviousValuesFieldDetails
      GroupSubscriptionPayload: GroupSubscriptionPayloadFieldDetails
      GroupPreviousValues: GroupPreviousValuesFieldDetails
      DiscussionSubscriptionPayload: DiscussionSubscriptionPayloadFieldDetails
      DiscussionPreviousValues: DiscussionPreviousValuesFieldDetails
      CommentSubscriptionPayload: CommentSubscriptionPayloadFieldDetails
      CommentPreviousValues: CommentPreviousValuesFieldDetails
    }
  }
  inputTypes: {
    fields: {
      UserWhereUniqueInput: UserWhereUniqueInputInputObject
      GroupWhereInput: GroupWhereInputInputObject
      UserWhereInput: UserWhereInputInputObject
      DiscussionWhereInput: DiscussionWhereInputInputObject
      CommentWhereInput: CommentWhereInputInputObject
      GroupWhereUniqueInput: GroupWhereUniqueInputInputObject
      DiscussionWhereUniqueInput: DiscussionWhereUniqueInputInputObject
      CommentWhereUniqueInput: CommentWhereUniqueInputInputObject
      UserCreateInput: UserCreateInputInputObject
      GroupCreateManyWithoutMembersInput: GroupCreateManyWithoutMembersInputInputObject
      GroupCreateWithoutMembersInput: GroupCreateWithoutMembersInputInputObject
      DiscussionCreateManyWithoutGroupInput: DiscussionCreateManyWithoutGroupInputInputObject
      DiscussionCreateWithoutGroupInput: DiscussionCreateWithoutGroupInputInputObject
      UserCreateOneWithoutAuthorOfInput: UserCreateOneWithoutAuthorOfInputInputObject
      UserCreateWithoutAuthorOfInput: UserCreateWithoutAuthorOfInputInputObject
      CommentCreateManyInput: CommentCreateManyInputInputObject
      CommentCreateInput: CommentCreateInputInputObject
      UserCreateOneInput: UserCreateOneInputInputObject
      CommentCreateOneInput: CommentCreateOneInputInputObject
      DiscussionCreateManyWithoutAuthorInput: DiscussionCreateManyWithoutAuthorInputInputObject
      DiscussionCreateWithoutAuthorInput: DiscussionCreateWithoutAuthorInputInputObject
      GroupCreateOneWithoutDiscussionsInput: GroupCreateOneWithoutDiscussionsInputInputObject
      GroupCreateWithoutDiscussionsInput: GroupCreateWithoutDiscussionsInputInputObject
      UserCreateManyWithoutGroupsJoinedInput: UserCreateManyWithoutGroupsJoinedInputInputObject
      UserCreateWithoutGroupsJoinedInput: UserCreateWithoutGroupsJoinedInputInputObject
      UserUpdateInput: UserUpdateInputInputObject
      GroupUpdateManyWithoutMembersInput: GroupUpdateManyWithoutMembersInputInputObject
      GroupUpdateWithWhereUniqueWithoutMembersInput: GroupUpdateWithWhereUniqueWithoutMembersInputInputObject
      GroupUpdateWithoutMembersDataInput: GroupUpdateWithoutMembersDataInputInputObject
      DiscussionUpdateManyWithoutGroupInput: DiscussionUpdateManyWithoutGroupInputInputObject
      DiscussionUpdateWithWhereUniqueWithoutGroupInput: DiscussionUpdateWithWhereUniqueWithoutGroupInputInputObject
      DiscussionUpdateWithoutGroupDataInput: DiscussionUpdateWithoutGroupDataInputInputObject
      UserUpdateOneRequiredWithoutAuthorOfInput: UserUpdateOneRequiredWithoutAuthorOfInputInputObject
      UserUpdateWithoutAuthorOfDataInput: UserUpdateWithoutAuthorOfDataInputInputObject
      UserUpsertWithoutAuthorOfInput: UserUpsertWithoutAuthorOfInputInputObject
      CommentUpdateManyInput: CommentUpdateManyInputInputObject
      CommentUpdateWithWhereUniqueNestedInput: CommentUpdateWithWhereUniqueNestedInputInputObject
      CommentUpdateDataInput: CommentUpdateDataInputInputObject
      UserUpdateOneRequiredInput: UserUpdateOneRequiredInputInputObject
      UserUpdateDataInput: UserUpdateDataInputInputObject
      DiscussionUpdateManyWithoutAuthorInput: DiscussionUpdateManyWithoutAuthorInputInputObject
      DiscussionUpdateWithWhereUniqueWithoutAuthorInput: DiscussionUpdateWithWhereUniqueWithoutAuthorInputInputObject
      DiscussionUpdateWithoutAuthorDataInput: DiscussionUpdateWithoutAuthorDataInputInputObject
      GroupUpdateOneRequiredWithoutDiscussionsInput: GroupUpdateOneRequiredWithoutDiscussionsInputInputObject
      GroupUpdateWithoutDiscussionsDataInput: GroupUpdateWithoutDiscussionsDataInputInputObject
      UserUpdateManyWithoutGroupsJoinedInput: UserUpdateManyWithoutGroupsJoinedInputInputObject
      UserUpdateWithWhereUniqueWithoutGroupsJoinedInput: UserUpdateWithWhereUniqueWithoutGroupsJoinedInputInputObject
      UserUpdateWithoutGroupsJoinedDataInput: UserUpdateWithoutGroupsJoinedDataInputInputObject
      UserUpsertWithWhereUniqueWithoutGroupsJoinedInput: UserUpsertWithWhereUniqueWithoutGroupsJoinedInputInputObject
      UserScalarWhereInput: UserScalarWhereInputInputObject
      UserUpdateManyWithWhereNestedInput: UserUpdateManyWithWhereNestedInputInputObject
      UserUpdateManyDataInput: UserUpdateManyDataInputInputObject
      GroupUpsertWithoutDiscussionsInput: GroupUpsertWithoutDiscussionsInputInputObject
      DiscussionUpsertWithWhereUniqueWithoutAuthorInput: DiscussionUpsertWithWhereUniqueWithoutAuthorInputInputObject
      DiscussionScalarWhereInput: DiscussionScalarWhereInputInputObject
      DiscussionUpdateManyWithWhereNestedInput: DiscussionUpdateManyWithWhereNestedInputInputObject
      DiscussionUpdateManyDataInput: DiscussionUpdateManyDataInputInputObject
      UserUpsertNestedInput: UserUpsertNestedInputInputObject
      CommentUpdateOneInput: CommentUpdateOneInputInputObject
      CommentUpsertNestedInput: CommentUpsertNestedInputInputObject
      CommentUpsertWithWhereUniqueNestedInput: CommentUpsertWithWhereUniqueNestedInputInputObject
      CommentScalarWhereInput: CommentScalarWhereInputInputObject
      CommentUpdateManyWithWhereNestedInput: CommentUpdateManyWithWhereNestedInputInputObject
      CommentUpdateManyDataInput: CommentUpdateManyDataInputInputObject
      DiscussionUpsertWithWhereUniqueWithoutGroupInput: DiscussionUpsertWithWhereUniqueWithoutGroupInputInputObject
      GroupUpsertWithWhereUniqueWithoutMembersInput: GroupUpsertWithWhereUniqueWithoutMembersInputInputObject
      GroupScalarWhereInput: GroupScalarWhereInputInputObject
      GroupUpdateManyWithWhereNestedInput: GroupUpdateManyWithWhereNestedInputInputObject
      GroupUpdateManyDataInput: GroupUpdateManyDataInputInputObject
      UserUpdateManyMutationInput: UserUpdateManyMutationInputInputObject
      GroupCreateInput: GroupCreateInputInputObject
      GroupUpdateInput: GroupUpdateInputInputObject
      GroupUpdateManyMutationInput: GroupUpdateManyMutationInputInputObject
      DiscussionCreateInput: DiscussionCreateInputInputObject
      DiscussionUpdateInput: DiscussionUpdateInputInputObject
      DiscussionUpdateManyMutationInput: DiscussionUpdateManyMutationInputInputObject
      CommentUpdateInput: CommentUpdateInputInputObject
      CommentUpdateManyMutationInput: CommentUpdateManyMutationInputInputObject
      UserSubscriptionWhereInput: UserSubscriptionWhereInputInputObject
      GroupSubscriptionWhereInput: GroupSubscriptionWhereInputInputObject
      DiscussionSubscriptionWhereInput: DiscussionSubscriptionWhereInputInputObject
      CommentSubscriptionWhereInput: CommentSubscriptionWhereInputInputObject
    }
  }
  enumTypes: {
    GroupOrderByInput: GroupOrderByInputValues,
    UserOrderByInput: UserOrderByInputValues,
    DiscussionOrderByInput: DiscussionOrderByInputValues,
    CommentOrderByInput: CommentOrderByInputValues,
    MutationType: MutationTypeValues,
  }
}

// Types for Query

type QueryObject =
  | QueryFields
  | { name: 'user', args?: QueryUserArgs[] | false, alias?: string  } 
  | { name: 'users', args?: QueryUsersArgs[] | false, alias?: string  } 
  | { name: 'usersConnection', args?: QueryUsersConnectionArgs[] | false, alias?: string  } 
  | { name: 'group', args?: QueryGroupArgs[] | false, alias?: string  } 
  | { name: 'groups', args?: QueryGroupsArgs[] | false, alias?: string  } 
  | { name: 'groupsConnection', args?: QueryGroupsConnectionArgs[] | false, alias?: string  } 
  | { name: 'discussion', args?: QueryDiscussionArgs[] | false, alias?: string  } 
  | { name: 'discussions', args?: QueryDiscussionsArgs[] | false, alias?: string  } 
  | { name: 'discussionsConnection', args?: QueryDiscussionsConnectionArgs[] | false, alias?: string  } 
  | { name: 'comment', args?: QueryCommentArgs[] | false, alias?: string  } 
  | { name: 'comments', args?: QueryCommentsArgs[] | false, alias?: string  } 
  | { name: 'commentsConnection', args?: QueryCommentsConnectionArgs[] | false, alias?: string  } 

type QueryFields =
  | 'user'
  | 'users'
  | 'usersConnection'
  | 'group'
  | 'groups'
  | 'groupsConnection'
  | 'discussion'
  | 'discussions'
  | 'discussionsConnection'
  | 'comment'
  | 'comments'
  | 'commentsConnection'


type QueryUserArgs =
  | 'where'
type QueryUsersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryUsersConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryGroupArgs =
  | 'where'
type QueryGroupsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryGroupsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryDiscussionArgs =
  | 'where'
type QueryDiscussionsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryDiscussionsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCommentArgs =
  | 'where'
type QueryCommentsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type QueryCommentsConnectionArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface QueryFieldDetails {
  user: {
    type: 'User'
    args: Record<QueryUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  users: {
    type: 'User'
    args: Record<QueryUsersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User[]> | prisma.User[]
  }
  usersConnection: {
    type: 'UserConnection'
    args: Record<QueryUsersConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserConnection> | prisma.UserConnection
  }
  group: {
    type: 'Group'
    args: Record<QueryGroupArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: GroupWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group | null> | prisma.Group | null
  }
  groups: {
    type: 'Group'
    args: Record<QueryGroupsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: GroupWhereInput | null, orderBy?: prisma.GroupOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group[]> | prisma.Group[]
  }
  groupsConnection: {
    type: 'GroupConnection'
    args: Record<QueryGroupsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: GroupWhereInput | null, orderBy?: prisma.GroupOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.GroupConnection> | prisma.GroupConnection
  }
  discussion: {
    type: 'Discussion'
    args: Record<QueryDiscussionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: DiscussionWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion | null> | prisma.Discussion | null
  }
  discussions: {
    type: 'Discussion'
    args: Record<QueryDiscussionsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: DiscussionWhereInput | null, orderBy?: prisma.DiscussionOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion[]> | prisma.Discussion[]
  }
  discussionsConnection: {
    type: 'DiscussionConnection'
    args: Record<QueryDiscussionsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: DiscussionWhereInput | null, orderBy?: prisma.DiscussionOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.DiscussionConnection> | prisma.DiscussionConnection
  }
  comment: {
    type: 'Comment'
    args: Record<QueryCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Query">,
      args: { where: CommentWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  comments: {
    type: 'Comment'
    args: Record<QueryCommentsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CommentWhereInput | null, orderBy?: prisma.CommentOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment[]> | prisma.Comment[]
  }
  commentsConnection: {
    type: 'CommentConnection'
    args: Record<QueryCommentsConnectionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Query">,
      args: { where?: CommentWhereInput | null, orderBy?: prisma.CommentOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CommentConnection> | prisma.CommentConnection
  }
}
  

// Types for User

type UserObject =
  | UserFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'guid', args?: [] | false, alias?: string  } 
  | { name: 'email', args?: [] | false, alias?: string  } 
  | { name: 'groupsJoined', args?: UserGroupsJoinedArgs[] | false, alias?: string  } 
  | { name: 'authorOf', args?: UserAuthorOfArgs[] | false, alias?: string  } 

type UserFields =
  | 'id'
  | 'guid'
  | 'email'
  | 'groupsJoined'
  | 'authorOf'


type UserGroupsJoinedArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type UserAuthorOfArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface UserFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  guid: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  email: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  groupsJoined: {
    type: 'Group'
    args: Record<UserGroupsJoinedArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"User">,
      args: { where?: GroupWhereInput | null, orderBy?: prisma.GroupOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group[]> | prisma.Group[]
  }
  authorOf: {
    type: 'Discussion'
    args: Record<UserAuthorOfArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"User">,
      args: { where?: DiscussionWhereInput | null, orderBy?: prisma.DiscussionOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion[]> | prisma.Discussion[]
  }
}
  

// Types for Group

type GroupObject =
  | GroupFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'guid', args?: [] | false, alias?: string  } 
  | { name: 'members', args?: GroupMembersArgs[] | false, alias?: string  } 
  | { name: 'discussions', args?: GroupDiscussionsArgs[] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'isPublic', args?: [] | false, alias?: string  } 

type GroupFields =
  | 'id'
  | 'guid'
  | 'members'
  | 'discussions'
  | 'name'
  | 'isPublic'


type GroupMembersArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
type GroupDiscussionsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface GroupFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  guid: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  members: {
    type: 'User'
    args: Record<GroupMembersArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Group">,
      args: { where?: UserWhereInput | null, orderBy?: prisma.UserOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User[]> | prisma.User[]
  }
  discussions: {
    type: 'Discussion'
    args: Record<GroupDiscussionsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Group">,
      args: { where?: DiscussionWhereInput | null, orderBy?: prisma.DiscussionOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion[]> | prisma.Discussion[]
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  isPublic: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Discussion

type DiscussionObject =
  | DiscussionFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'guid', args?: [] | false, alias?: string  } 
  | { name: 'author', args?: [] | false, alias?: string  } 
  | { name: 'group', args?: [] | false, alias?: string  } 
  | { name: 'comments', args?: DiscussionCommentsArgs[] | false, alias?: string  } 
  | { name: 'title', args?: [] | false, alias?: string  } 
  | { name: 'content', args?: [] | false, alias?: string  } 

type DiscussionFields =
  | 'id'
  | 'guid'
  | 'author'
  | 'group'
  | 'comments'
  | 'title'
  | 'content'


type DiscussionCommentsArgs =
  | 'where'
  | 'orderBy'
  | 'skip'
  | 'after'
  | 'before'
  | 'first'
  | 'last'
  

export interface DiscussionFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  guid: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  author: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Discussion">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  group: {
    type: 'Group'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Discussion">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group> | prisma.Group
  }
  comments: {
    type: 'Comment'
    args: Record<DiscussionCommentsArgs, core.NexusArgDef<string>>
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"Discussion">,
      args: { where?: CommentWhereInput | null, orderBy?: prisma.CommentOrderByInput | null, skip?: number | null, after?: string | null, before?: string | null, first?: number | null, last?: number | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment[]> | prisma.Comment[]
  }
  title: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  content: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Comment

type CommentObject =
  | CommentFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'guid', args?: [] | false, alias?: string  } 
  | { name: 'author', args?: [] | false, alias?: string  } 
  | { name: 'parentComment', args?: [] | false, alias?: string  } 
  | { name: 'content', args?: [] | false, alias?: string  } 

type CommentFields =
  | 'id'
  | 'guid'
  | 'author'
  | 'parentComment'
  | 'content'



  

export interface CommentFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  guid: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  author: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Comment">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  parentComment: {
    type: 'Comment'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Comment">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  content: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for UserConnection

type UserConnectionObject =
  | UserConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type UserConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface UserConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'UserEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserEdge[]> | prisma.UserEdge[]
  }
  aggregate: {
    type: 'AggregateUser'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateUser> | prisma.AggregateUser
  }
}
  

// Types for PageInfo

type PageInfoObject =
  | PageInfoFields
  | { name: 'hasNextPage', args?: [] | false, alias?: string  } 
  | { name: 'hasPreviousPage', args?: [] | false, alias?: string  } 
  | { name: 'startCursor', args?: [] | false, alias?: string  } 
  | { name: 'endCursor', args?: [] | false, alias?: string  } 

type PageInfoFields =
  | 'hasNextPage'
  | 'hasPreviousPage'
  | 'startCursor'
  | 'endCursor'



  

export interface PageInfoFieldDetails {
  hasNextPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  hasPreviousPage: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  startCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
  endCursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: undefined
  }
}
  

// Types for UserEdge

type UserEdgeObject =
  | UserEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type UserEdgeFields =
  | 'node'
  | 'cursor'



  

export interface UserEdgeFieldDetails {
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateUser

type AggregateUserObject =
  | AggregateUserFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateUserFields =
  | 'count'



  

export interface AggregateUserFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for GroupConnection

type GroupConnectionObject =
  | GroupConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type GroupConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface GroupConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"GroupConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'GroupEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"GroupConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.GroupEdge[]> | prisma.GroupEdge[]
  }
  aggregate: {
    type: 'AggregateGroup'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"GroupConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateGroup> | prisma.AggregateGroup
  }
}
  

// Types for GroupEdge

type GroupEdgeObject =
  | GroupEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type GroupEdgeFields =
  | 'node'
  | 'cursor'



  

export interface GroupEdgeFieldDetails {
  node: {
    type: 'Group'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"GroupEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group> | prisma.Group
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateGroup

type AggregateGroupObject =
  | AggregateGroupFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateGroupFields =
  | 'count'



  

export interface AggregateGroupFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for DiscussionConnection

type DiscussionConnectionObject =
  | DiscussionConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type DiscussionConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface DiscussionConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"DiscussionConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'DiscussionEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"DiscussionConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.DiscussionEdge[]> | prisma.DiscussionEdge[]
  }
  aggregate: {
    type: 'AggregateDiscussion'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"DiscussionConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateDiscussion> | prisma.AggregateDiscussion
  }
}
  

// Types for DiscussionEdge

type DiscussionEdgeObject =
  | DiscussionEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type DiscussionEdgeFields =
  | 'node'
  | 'cursor'



  

export interface DiscussionEdgeFieldDetails {
  node: {
    type: 'Discussion'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"DiscussionEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion> | prisma.Discussion
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateDiscussion

type AggregateDiscussionObject =
  | AggregateDiscussionFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateDiscussionFields =
  | 'count'



  

export interface AggregateDiscussionFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CommentConnection

type CommentConnectionObject =
  | CommentConnectionFields
  | { name: 'pageInfo', args?: [] | false, alias?: string  } 
  | { name: 'edges', args?: [] | false, alias?: string  } 
  | { name: 'aggregate', args?: [] | false, alias?: string  } 

type CommentConnectionFields =
  | 'pageInfo'
  | 'edges'
  | 'aggregate'



  

export interface CommentConnectionFieldDetails {
  pageInfo: {
    type: 'PageInfo'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CommentConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.PageInfo> | prisma.PageInfo
  }
  edges: {
    type: 'CommentEdge'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: (
      root: core.RootValue<"CommentConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CommentEdge[]> | prisma.CommentEdge[]
  }
  aggregate: {
    type: 'AggregateComment'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CommentConnection">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.AggregateComment> | prisma.AggregateComment
  }
}
  

// Types for CommentEdge

type CommentEdgeObject =
  | CommentEdgeFields
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'cursor', args?: [] | false, alias?: string  } 

type CommentEdgeFields =
  | 'node'
  | 'cursor'



  

export interface CommentEdgeFieldDetails {
  node: {
    type: 'Comment'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CommentEdge">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment> | prisma.Comment
  }
  cursor: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for AggregateComment

type AggregateCommentObject =
  | AggregateCommentFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type AggregateCommentFields =
  | 'count'



  

export interface AggregateCommentFieldDetails {
  count: {
    type: 'Int'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Mutation

type MutationObject =
  | MutationFields
  | { name: 'createUser', args?: MutationCreateUserArgs[] | false, alias?: string  } 
  | { name: 'updateUser', args?: MutationUpdateUserArgs[] | false, alias?: string  } 
  | { name: 'updateManyUsers', args?: MutationUpdateManyUsersArgs[] | false, alias?: string  } 
  | { name: 'upsertUser', args?: MutationUpsertUserArgs[] | false, alias?: string  } 
  | { name: 'deleteUser', args?: MutationDeleteUserArgs[] | false, alias?: string  } 
  | { name: 'deleteManyUsers', args?: MutationDeleteManyUsersArgs[] | false, alias?: string  } 
  | { name: 'createGroup', args?: MutationCreateGroupArgs[] | false, alias?: string  } 
  | { name: 'updateGroup', args?: MutationUpdateGroupArgs[] | false, alias?: string  } 
  | { name: 'updateManyGroups', args?: MutationUpdateManyGroupsArgs[] | false, alias?: string  } 
  | { name: 'upsertGroup', args?: MutationUpsertGroupArgs[] | false, alias?: string  } 
  | { name: 'deleteGroup', args?: MutationDeleteGroupArgs[] | false, alias?: string  } 
  | { name: 'deleteManyGroups', args?: MutationDeleteManyGroupsArgs[] | false, alias?: string  } 
  | { name: 'createDiscussion', args?: MutationCreateDiscussionArgs[] | false, alias?: string  } 
  | { name: 'updateDiscussion', args?: MutationUpdateDiscussionArgs[] | false, alias?: string  } 
  | { name: 'updateManyDiscussions', args?: MutationUpdateManyDiscussionsArgs[] | false, alias?: string  } 
  | { name: 'upsertDiscussion', args?: MutationUpsertDiscussionArgs[] | false, alias?: string  } 
  | { name: 'deleteDiscussion', args?: MutationDeleteDiscussionArgs[] | false, alias?: string  } 
  | { name: 'deleteManyDiscussions', args?: MutationDeleteManyDiscussionsArgs[] | false, alias?: string  } 
  | { name: 'createComment', args?: MutationCreateCommentArgs[] | false, alias?: string  } 
  | { name: 'updateComment', args?: MutationUpdateCommentArgs[] | false, alias?: string  } 
  | { name: 'updateManyComments', args?: MutationUpdateManyCommentsArgs[] | false, alias?: string  } 
  | { name: 'upsertComment', args?: MutationUpsertCommentArgs[] | false, alias?: string  } 
  | { name: 'deleteComment', args?: MutationDeleteCommentArgs[] | false, alias?: string  } 
  | { name: 'deleteManyComments', args?: MutationDeleteManyCommentsArgs[] | false, alias?: string  } 

type MutationFields =
  | 'createUser'
  | 'updateUser'
  | 'updateManyUsers'
  | 'upsertUser'
  | 'deleteUser'
  | 'deleteManyUsers'
  | 'createGroup'
  | 'updateGroup'
  | 'updateManyGroups'
  | 'upsertGroup'
  | 'deleteGroup'
  | 'deleteManyGroups'
  | 'createDiscussion'
  | 'updateDiscussion'
  | 'updateManyDiscussions'
  | 'upsertDiscussion'
  | 'deleteDiscussion'
  | 'deleteManyDiscussions'
  | 'createComment'
  | 'updateComment'
  | 'updateManyComments'
  | 'upsertComment'
  | 'deleteComment'
  | 'deleteManyComments'


type MutationCreateUserArgs =
  | 'data'
type MutationUpdateUserArgs =
  | 'data'
  | 'where'
type MutationUpdateManyUsersArgs =
  | 'data'
  | 'where'
type MutationUpsertUserArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteUserArgs =
  | 'where'
type MutationDeleteManyUsersArgs =
  | 'where'
type MutationCreateGroupArgs =
  | 'data'
type MutationUpdateGroupArgs =
  | 'data'
  | 'where'
type MutationUpdateManyGroupsArgs =
  | 'data'
  | 'where'
type MutationUpsertGroupArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteGroupArgs =
  | 'where'
type MutationDeleteManyGroupsArgs =
  | 'where'
type MutationCreateDiscussionArgs =
  | 'data'
type MutationUpdateDiscussionArgs =
  | 'data'
  | 'where'
type MutationUpdateManyDiscussionsArgs =
  | 'data'
  | 'where'
type MutationUpsertDiscussionArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteDiscussionArgs =
  | 'where'
type MutationDeleteManyDiscussionsArgs =
  | 'where'
type MutationCreateCommentArgs =
  | 'data'
type MutationUpdateCommentArgs =
  | 'data'
  | 'where'
type MutationUpdateManyCommentsArgs =
  | 'data'
  | 'where'
type MutationUpsertCommentArgs =
  | 'where'
  | 'create'
  | 'update'
type MutationDeleteCommentArgs =
  | 'where'
type MutationDeleteManyCommentsArgs =
  | 'where'
  

export interface MutationFieldDetails {
  createUser: {
    type: 'User'
    args: Record<MutationCreateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  updateUser: {
    type: 'User'
    args: Record<MutationUpdateUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateInput, where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updateManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: UserUpdateManyMutationInput, where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertUser: {
    type: 'User'
    args: Record<MutationUpsertUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput, create: UserCreateInput, update: UserUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User> | prisma.User
  }
  deleteUser: {
    type: 'User'
    args: Record<MutationDeleteUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: UserWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  deleteManyUsers: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyUsersArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: UserWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createGroup: {
    type: 'Group'
    args: Record<MutationCreateGroupArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: GroupCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group> | prisma.Group
  }
  updateGroup: {
    type: 'Group'
    args: Record<MutationUpdateGroupArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: GroupUpdateInput, where: GroupWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group | null> | prisma.Group | null
  }
  updateManyGroups: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyGroupsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: GroupUpdateManyMutationInput, where?: GroupWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertGroup: {
    type: 'Group'
    args: Record<MutationUpsertGroupArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: GroupWhereUniqueInput, create: GroupCreateInput, update: GroupUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group> | prisma.Group
  }
  deleteGroup: {
    type: 'Group'
    args: Record<MutationDeleteGroupArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: GroupWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group | null> | prisma.Group | null
  }
  deleteManyGroups: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyGroupsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: GroupWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createDiscussion: {
    type: 'Discussion'
    args: Record<MutationCreateDiscussionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: DiscussionCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion> | prisma.Discussion
  }
  updateDiscussion: {
    type: 'Discussion'
    args: Record<MutationUpdateDiscussionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: DiscussionUpdateInput, where: DiscussionWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion | null> | prisma.Discussion | null
  }
  updateManyDiscussions: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyDiscussionsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: DiscussionUpdateManyMutationInput, where?: DiscussionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertDiscussion: {
    type: 'Discussion'
    args: Record<MutationUpsertDiscussionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: DiscussionWhereUniqueInput, create: DiscussionCreateInput, update: DiscussionUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion> | prisma.Discussion
  }
  deleteDiscussion: {
    type: 'Discussion'
    args: Record<MutationDeleteDiscussionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: DiscussionWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion | null> | prisma.Discussion | null
  }
  deleteManyDiscussions: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyDiscussionsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: DiscussionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  createComment: {
    type: 'Comment'
    args: Record<MutationCreateCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CommentCreateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment> | prisma.Comment
  }
  updateComment: {
    type: 'Comment'
    args: Record<MutationUpdateCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CommentUpdateInput, where: CommentWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  updateManyComments: {
    type: 'BatchPayload'
    args: Record<MutationUpdateManyCommentsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { data: CommentUpdateManyMutationInput, where?: CommentWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
  upsertComment: {
    type: 'Comment'
    args: Record<MutationUpsertCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CommentWhereUniqueInput, create: CommentCreateInput, update: CommentUpdateInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment> | prisma.Comment
  }
  deleteComment: {
    type: 'Comment'
    args: Record<MutationDeleteCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where: CommentWhereUniqueInput }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  deleteManyComments: {
    type: 'BatchPayload'
    args: Record<MutationDeleteManyCommentsArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"Mutation">,
      args: { where?: CommentWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.BatchPayload> | prisma.BatchPayload
  }
}
  

// Types for BatchPayload

type BatchPayloadObject =
  | BatchPayloadFields
  | { name: 'count', args?: [] | false, alias?: string  } 

type BatchPayloadFields =
  | 'count'



  

export interface BatchPayloadFieldDetails {
  count: {
    type: 'Long'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for Subscription

type SubscriptionObject =
  | SubscriptionFields
  | { name: 'user', args?: SubscriptionUserArgs[] | false, alias?: string  } 
  | { name: 'group', args?: SubscriptionGroupArgs[] | false, alias?: string  } 
  | { name: 'discussion', args?: SubscriptionDiscussionArgs[] | false, alias?: string  } 
  | { name: 'comment', args?: SubscriptionCommentArgs[] | false, alias?: string  } 

type SubscriptionFields =
  | 'user'
  | 'group'
  | 'discussion'
  | 'comment'


type SubscriptionUserArgs =
  | 'where'
type SubscriptionGroupArgs =
  | 'where'
type SubscriptionDiscussionArgs =
  | 'where'
type SubscriptionCommentArgs =
  | 'where'
  

export interface SubscriptionFieldDetails {
  user: {
    type: 'UserSubscriptionPayload'
    args: Record<SubscriptionUserArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: UserSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserSubscriptionPayload | null> | prisma.UserSubscriptionPayload | null
  }
  group: {
    type: 'GroupSubscriptionPayload'
    args: Record<SubscriptionGroupArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: GroupSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.GroupSubscriptionPayload | null> | prisma.GroupSubscriptionPayload | null
  }
  discussion: {
    type: 'DiscussionSubscriptionPayload'
    args: Record<SubscriptionDiscussionArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: DiscussionSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.DiscussionSubscriptionPayload | null> | prisma.DiscussionSubscriptionPayload | null
  }
  comment: {
    type: 'CommentSubscriptionPayload'
    args: Record<SubscriptionCommentArgs, core.NexusArgDef<string>>
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"Subscription">,
      args: { where?: CommentSubscriptionWhereInput | null }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CommentSubscriptionPayload | null> | prisma.CommentSubscriptionPayload | null
  }
}
  

// Types for UserSubscriptionPayload

type UserSubscriptionPayloadObject =
  | UserSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type UserSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface UserSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'User'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.User | null> | prisma.User | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'UserPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"UserSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.UserPreviousValues | null> | prisma.UserPreviousValues | null
  }
}
  

// Types for UserPreviousValues

type UserPreviousValuesObject =
  | UserPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'guid', args?: [] | false, alias?: string  } 
  | { name: 'email', args?: [] | false, alias?: string  } 

type UserPreviousValuesFields =
  | 'id'
  | 'guid'
  | 'email'



  

export interface UserPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  guid: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  email: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for GroupSubscriptionPayload

type GroupSubscriptionPayloadObject =
  | GroupSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type GroupSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface GroupSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"GroupSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Group'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"GroupSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Group | null> | prisma.Group | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'GroupPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"GroupSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.GroupPreviousValues | null> | prisma.GroupPreviousValues | null
  }
}
  

// Types for GroupPreviousValues

type GroupPreviousValuesObject =
  | GroupPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'guid', args?: [] | false, alias?: string  } 
  | { name: 'name', args?: [] | false, alias?: string  } 
  | { name: 'isPublic', args?: [] | false, alias?: string  } 

type GroupPreviousValuesFields =
  | 'id'
  | 'guid'
  | 'name'
  | 'isPublic'



  

export interface GroupPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  guid: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  name: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  isPublic: {
    type: 'Boolean'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for DiscussionSubscriptionPayload

type DiscussionSubscriptionPayloadObject =
  | DiscussionSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type DiscussionSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface DiscussionSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"DiscussionSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Discussion'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"DiscussionSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Discussion | null> | prisma.Discussion | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'DiscussionPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"DiscussionSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.DiscussionPreviousValues | null> | prisma.DiscussionPreviousValues | null
  }
}
  

// Types for DiscussionPreviousValues

type DiscussionPreviousValuesObject =
  | DiscussionPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'guid', args?: [] | false, alias?: string  } 
  | { name: 'title', args?: [] | false, alias?: string  } 
  | { name: 'content', args?: [] | false, alias?: string  } 

type DiscussionPreviousValuesFields =
  | 'id'
  | 'guid'
  | 'title'
  | 'content'



  

export interface DiscussionPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  guid: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  title: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  content: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  

// Types for CommentSubscriptionPayload

type CommentSubscriptionPayloadObject =
  | CommentSubscriptionPayloadFields
  | { name: 'mutation', args?: [] | false, alias?: string  } 
  | { name: 'node', args?: [] | false, alias?: string  } 
  | { name: 'updatedFields', args?: [] | false, alias?: string  } 
  | { name: 'previousValues', args?: [] | false, alias?: string  } 

type CommentSubscriptionPayloadFields =
  | 'mutation'
  | 'node'
  | 'updatedFields'
  | 'previousValues'



  

export interface CommentSubscriptionPayloadFieldDetails {
  mutation: {
    type: 'MutationType'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: (
      root: core.RootValue<"CommentSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.MutationType> | prisma.MutationType
  }
  node: {
    type: 'Comment'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CommentSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.Comment | null> | prisma.Comment | null
  }
  updatedFields: {
    type: 'String'
    args: {}
    description: string
    list: true
    nullable: false
    resolve: undefined
  }
  previousValues: {
    type: 'CommentPreviousValues'
    args: {}
    description: string
    list: undefined
    nullable: true
    resolve: (
      root: core.RootValue<"CommentSubscriptionPayload">,
      args: {  }  ,
      context: core.GetGen<"context">,
      info?: GraphQLResolveInfo
    ) => Promise<prisma.CommentPreviousValues | null> | prisma.CommentPreviousValues | null
  }
}
  

// Types for CommentPreviousValues

type CommentPreviousValuesObject =
  | CommentPreviousValuesFields
  | { name: 'id', args?: [] | false, alias?: string  } 
  | { name: 'guid', args?: [] | false, alias?: string  } 
  | { name: 'content', args?: [] | false, alias?: string  } 

type CommentPreviousValuesFields =
  | 'id'
  | 'guid'
  | 'content'



  

export interface CommentPreviousValuesFieldDetails {
  id: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  guid: {
    type: 'ID'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
  content: {
    type: 'String'
    args: {}
    description: string
    list: undefined
    nullable: false
    resolve: undefined
  }
}
  


export interface UserWhereUniqueInput {
  id?: string | null
  guid?: string | null
}
export type UserWhereUniqueInputInputObject =
  | Extract<keyof UserWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  
export interface GroupWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  guid?: string | null
  guid_not?: string | null
  guid_in?: string[]
  guid_not_in?: string[]
  guid_lt?: string | null
  guid_lte?: string | null
  guid_gt?: string | null
  guid_gte?: string | null
  guid_contains?: string | null
  guid_not_contains?: string | null
  guid_starts_with?: string | null
  guid_not_starts_with?: string | null
  guid_ends_with?: string | null
  guid_not_ends_with?: string | null
  members_every?: UserWhereInput | null
  members_some?: UserWhereInput | null
  members_none?: UserWhereInput | null
  discussions_every?: DiscussionWhereInput | null
  discussions_some?: DiscussionWhereInput | null
  discussions_none?: DiscussionWhereInput | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  isPublic?: boolean | null
  isPublic_not?: boolean | null
  AND?: GroupWhereInput[]
  OR?: GroupWhereInput[]
  NOT?: GroupWhereInput[]
}
export type GroupWhereInputInputObject =
  | Extract<keyof GroupWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'guid_not', alias?: string  } 
  | { name: 'guid_in', alias?: string  } 
  | { name: 'guid_not_in', alias?: string  } 
  | { name: 'guid_lt', alias?: string  } 
  | { name: 'guid_lte', alias?: string  } 
  | { name: 'guid_gt', alias?: string  } 
  | { name: 'guid_gte', alias?: string  } 
  | { name: 'guid_contains', alias?: string  } 
  | { name: 'guid_not_contains', alias?: string  } 
  | { name: 'guid_starts_with', alias?: string  } 
  | { name: 'guid_not_starts_with', alias?: string  } 
  | { name: 'guid_ends_with', alias?: string  } 
  | { name: 'guid_not_ends_with', alias?: string  } 
  | { name: 'members_every', alias?: string  } 
  | { name: 'members_some', alias?: string  } 
  | { name: 'members_none', alias?: string  } 
  | { name: 'discussions_every', alias?: string  } 
  | { name: 'discussions_some', alias?: string  } 
  | { name: 'discussions_none', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  | { name: 'isPublic_not', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface UserWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  guid?: string | null
  guid_not?: string | null
  guid_in?: string[]
  guid_not_in?: string[]
  guid_lt?: string | null
  guid_lte?: string | null
  guid_gt?: string | null
  guid_gte?: string | null
  guid_contains?: string | null
  guid_not_contains?: string | null
  guid_starts_with?: string | null
  guid_not_starts_with?: string | null
  guid_ends_with?: string | null
  guid_not_ends_with?: string | null
  email?: string | null
  email_not?: string | null
  email_in?: string[]
  email_not_in?: string[]
  email_lt?: string | null
  email_lte?: string | null
  email_gt?: string | null
  email_gte?: string | null
  email_contains?: string | null
  email_not_contains?: string | null
  email_starts_with?: string | null
  email_not_starts_with?: string | null
  email_ends_with?: string | null
  email_not_ends_with?: string | null
  groupsJoined_every?: GroupWhereInput | null
  groupsJoined_some?: GroupWhereInput | null
  groupsJoined_none?: GroupWhereInput | null
  authorOf_every?: DiscussionWhereInput | null
  authorOf_some?: DiscussionWhereInput | null
  authorOf_none?: DiscussionWhereInput | null
  AND?: UserWhereInput[]
  OR?: UserWhereInput[]
  NOT?: UserWhereInput[]
}
export type UserWhereInputInputObject =
  | Extract<keyof UserWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'guid_not', alias?: string  } 
  | { name: 'guid_in', alias?: string  } 
  | { name: 'guid_not_in', alias?: string  } 
  | { name: 'guid_lt', alias?: string  } 
  | { name: 'guid_lte', alias?: string  } 
  | { name: 'guid_gt', alias?: string  } 
  | { name: 'guid_gte', alias?: string  } 
  | { name: 'guid_contains', alias?: string  } 
  | { name: 'guid_not_contains', alias?: string  } 
  | { name: 'guid_starts_with', alias?: string  } 
  | { name: 'guid_not_starts_with', alias?: string  } 
  | { name: 'guid_ends_with', alias?: string  } 
  | { name: 'guid_not_ends_with', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'email_not', alias?: string  } 
  | { name: 'email_in', alias?: string  } 
  | { name: 'email_not_in', alias?: string  } 
  | { name: 'email_lt', alias?: string  } 
  | { name: 'email_lte', alias?: string  } 
  | { name: 'email_gt', alias?: string  } 
  | { name: 'email_gte', alias?: string  } 
  | { name: 'email_contains', alias?: string  } 
  | { name: 'email_not_contains', alias?: string  } 
  | { name: 'email_starts_with', alias?: string  } 
  | { name: 'email_not_starts_with', alias?: string  } 
  | { name: 'email_ends_with', alias?: string  } 
  | { name: 'email_not_ends_with', alias?: string  } 
  | { name: 'groupsJoined_every', alias?: string  } 
  | { name: 'groupsJoined_some', alias?: string  } 
  | { name: 'groupsJoined_none', alias?: string  } 
  | { name: 'authorOf_every', alias?: string  } 
  | { name: 'authorOf_some', alias?: string  } 
  | { name: 'authorOf_none', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface DiscussionWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  guid?: string | null
  guid_not?: string | null
  guid_in?: string[]
  guid_not_in?: string[]
  guid_lt?: string | null
  guid_lte?: string | null
  guid_gt?: string | null
  guid_gte?: string | null
  guid_contains?: string | null
  guid_not_contains?: string | null
  guid_starts_with?: string | null
  guid_not_starts_with?: string | null
  guid_ends_with?: string | null
  guid_not_ends_with?: string | null
  author?: UserWhereInput | null
  group?: GroupWhereInput | null
  comments_every?: CommentWhereInput | null
  comments_some?: CommentWhereInput | null
  comments_none?: CommentWhereInput | null
  title?: string | null
  title_not?: string | null
  title_in?: string[]
  title_not_in?: string[]
  title_lt?: string | null
  title_lte?: string | null
  title_gt?: string | null
  title_gte?: string | null
  title_contains?: string | null
  title_not_contains?: string | null
  title_starts_with?: string | null
  title_not_starts_with?: string | null
  title_ends_with?: string | null
  title_not_ends_with?: string | null
  content?: string | null
  content_not?: string | null
  content_in?: string[]
  content_not_in?: string[]
  content_lt?: string | null
  content_lte?: string | null
  content_gt?: string | null
  content_gte?: string | null
  content_contains?: string | null
  content_not_contains?: string | null
  content_starts_with?: string | null
  content_not_starts_with?: string | null
  content_ends_with?: string | null
  content_not_ends_with?: string | null
  AND?: DiscussionWhereInput[]
  OR?: DiscussionWhereInput[]
  NOT?: DiscussionWhereInput[]
}
export type DiscussionWhereInputInputObject =
  | Extract<keyof DiscussionWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'guid_not', alias?: string  } 
  | { name: 'guid_in', alias?: string  } 
  | { name: 'guid_not_in', alias?: string  } 
  | { name: 'guid_lt', alias?: string  } 
  | { name: 'guid_lte', alias?: string  } 
  | { name: 'guid_gt', alias?: string  } 
  | { name: 'guid_gte', alias?: string  } 
  | { name: 'guid_contains', alias?: string  } 
  | { name: 'guid_not_contains', alias?: string  } 
  | { name: 'guid_starts_with', alias?: string  } 
  | { name: 'guid_not_starts_with', alias?: string  } 
  | { name: 'guid_ends_with', alias?: string  } 
  | { name: 'guid_not_ends_with', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'group', alias?: string  } 
  | { name: 'comments_every', alias?: string  } 
  | { name: 'comments_some', alias?: string  } 
  | { name: 'comments_none', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'title_not', alias?: string  } 
  | { name: 'title_in', alias?: string  } 
  | { name: 'title_not_in', alias?: string  } 
  | { name: 'title_lt', alias?: string  } 
  | { name: 'title_lte', alias?: string  } 
  | { name: 'title_gt', alias?: string  } 
  | { name: 'title_gte', alias?: string  } 
  | { name: 'title_contains', alias?: string  } 
  | { name: 'title_not_contains', alias?: string  } 
  | { name: 'title_starts_with', alias?: string  } 
  | { name: 'title_not_starts_with', alias?: string  } 
  | { name: 'title_ends_with', alias?: string  } 
  | { name: 'title_not_ends_with', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'content_not', alias?: string  } 
  | { name: 'content_in', alias?: string  } 
  | { name: 'content_not_in', alias?: string  } 
  | { name: 'content_lt', alias?: string  } 
  | { name: 'content_lte', alias?: string  } 
  | { name: 'content_gt', alias?: string  } 
  | { name: 'content_gte', alias?: string  } 
  | { name: 'content_contains', alias?: string  } 
  | { name: 'content_not_contains', alias?: string  } 
  | { name: 'content_starts_with', alias?: string  } 
  | { name: 'content_not_starts_with', alias?: string  } 
  | { name: 'content_ends_with', alias?: string  } 
  | { name: 'content_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CommentWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  guid?: string | null
  guid_not?: string | null
  guid_in?: string[]
  guid_not_in?: string[]
  guid_lt?: string | null
  guid_lte?: string | null
  guid_gt?: string | null
  guid_gte?: string | null
  guid_contains?: string | null
  guid_not_contains?: string | null
  guid_starts_with?: string | null
  guid_not_starts_with?: string | null
  guid_ends_with?: string | null
  guid_not_ends_with?: string | null
  author?: UserWhereInput | null
  parentComment?: CommentWhereInput | null
  content?: string | null
  content_not?: string | null
  content_in?: string[]
  content_not_in?: string[]
  content_lt?: string | null
  content_lte?: string | null
  content_gt?: string | null
  content_gte?: string | null
  content_contains?: string | null
  content_not_contains?: string | null
  content_starts_with?: string | null
  content_not_starts_with?: string | null
  content_ends_with?: string | null
  content_not_ends_with?: string | null
  AND?: CommentWhereInput[]
  OR?: CommentWhereInput[]
  NOT?: CommentWhereInput[]
}
export type CommentWhereInputInputObject =
  | Extract<keyof CommentWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'guid_not', alias?: string  } 
  | { name: 'guid_in', alias?: string  } 
  | { name: 'guid_not_in', alias?: string  } 
  | { name: 'guid_lt', alias?: string  } 
  | { name: 'guid_lte', alias?: string  } 
  | { name: 'guid_gt', alias?: string  } 
  | { name: 'guid_gte', alias?: string  } 
  | { name: 'guid_contains', alias?: string  } 
  | { name: 'guid_not_contains', alias?: string  } 
  | { name: 'guid_starts_with', alias?: string  } 
  | { name: 'guid_not_starts_with', alias?: string  } 
  | { name: 'guid_ends_with', alias?: string  } 
  | { name: 'guid_not_ends_with', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'parentComment', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'content_not', alias?: string  } 
  | { name: 'content_in', alias?: string  } 
  | { name: 'content_not_in', alias?: string  } 
  | { name: 'content_lt', alias?: string  } 
  | { name: 'content_lte', alias?: string  } 
  | { name: 'content_gt', alias?: string  } 
  | { name: 'content_gte', alias?: string  } 
  | { name: 'content_contains', alias?: string  } 
  | { name: 'content_not_contains', alias?: string  } 
  | { name: 'content_starts_with', alias?: string  } 
  | { name: 'content_not_starts_with', alias?: string  } 
  | { name: 'content_ends_with', alias?: string  } 
  | { name: 'content_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface GroupWhereUniqueInput {
  id?: string | null
  guid?: string | null
}
export type GroupWhereUniqueInputInputObject =
  | Extract<keyof GroupWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  
export interface DiscussionWhereUniqueInput {
  id?: string | null
  guid?: string | null
}
export type DiscussionWhereUniqueInputInputObject =
  | Extract<keyof DiscussionWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  
export interface CommentWhereUniqueInput {
  id?: string | null
  guid?: string | null
}
export type CommentWhereUniqueInputInputObject =
  | Extract<keyof CommentWhereUniqueInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  
export interface UserCreateInput {
  id?: string | null
  guid?: string
  email?: string
  groupsJoined?: GroupCreateManyWithoutMembersInput | null
  authorOf?: DiscussionCreateManyWithoutAuthorInput | null
}
export type UserCreateInputInputObject =
  | Extract<keyof UserCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'groupsJoined', alias?: string  } 
  | { name: 'authorOf', alias?: string  } 
  
export interface GroupCreateManyWithoutMembersInput {
  create?: GroupCreateWithoutMembersInput[]
  connect?: GroupWhereUniqueInput[]
}
export type GroupCreateManyWithoutMembersInputInputObject =
  | Extract<keyof GroupCreateManyWithoutMembersInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface GroupCreateWithoutMembersInput {
  id?: string | null
  guid?: string
  discussions?: DiscussionCreateManyWithoutGroupInput | null
  name?: string
  isPublic?: boolean
}
export type GroupCreateWithoutMembersInputInputObject =
  | Extract<keyof GroupCreateWithoutMembersInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'discussions', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  
export interface DiscussionCreateManyWithoutGroupInput {
  create?: DiscussionCreateWithoutGroupInput[]
  connect?: DiscussionWhereUniqueInput[]
}
export type DiscussionCreateManyWithoutGroupInputInputObject =
  | Extract<keyof DiscussionCreateManyWithoutGroupInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface DiscussionCreateWithoutGroupInput {
  id?: string | null
  guid?: string
  author?: UserCreateOneWithoutAuthorOfInput
  comments?: CommentCreateManyInput | null
  title?: string
  content?: string
}
export type DiscussionCreateWithoutGroupInputInputObject =
  | Extract<keyof DiscussionCreateWithoutGroupInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface UserCreateOneWithoutAuthorOfInput {
  create?: UserCreateWithoutAuthorOfInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserCreateOneWithoutAuthorOfInputInputObject =
  | Extract<keyof UserCreateOneWithoutAuthorOfInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserCreateWithoutAuthorOfInput {
  id?: string | null
  guid?: string
  email?: string
  groupsJoined?: GroupCreateManyWithoutMembersInput | null
}
export type UserCreateWithoutAuthorOfInputInputObject =
  | Extract<keyof UserCreateWithoutAuthorOfInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'groupsJoined', alias?: string  } 
  
export interface CommentCreateManyInput {
  create?: CommentCreateInput[]
  connect?: CommentWhereUniqueInput[]
}
export type CommentCreateManyInputInputObject =
  | Extract<keyof CommentCreateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface CommentCreateInput {
  id?: string | null
  guid?: string
  author?: UserCreateOneInput
  parentComment?: CommentCreateOneInput | null
  content?: string
}
export type CommentCreateInputInputObject =
  | Extract<keyof CommentCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'parentComment', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface UserCreateOneInput {
  create?: UserCreateInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserCreateOneInputInputObject =
  | Extract<keyof UserCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface CommentCreateOneInput {
  create?: CommentCreateInput | null
  connect?: CommentWhereUniqueInput | null
}
export type CommentCreateOneInputInputObject =
  | Extract<keyof CommentCreateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface DiscussionCreateManyWithoutAuthorInput {
  create?: DiscussionCreateWithoutAuthorInput[]
  connect?: DiscussionWhereUniqueInput[]
}
export type DiscussionCreateManyWithoutAuthorInputInputObject =
  | Extract<keyof DiscussionCreateManyWithoutAuthorInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface DiscussionCreateWithoutAuthorInput {
  id?: string | null
  guid?: string
  group?: GroupCreateOneWithoutDiscussionsInput
  comments?: CommentCreateManyInput | null
  title?: string
  content?: string
}
export type DiscussionCreateWithoutAuthorInputInputObject =
  | Extract<keyof DiscussionCreateWithoutAuthorInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'group', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface GroupCreateOneWithoutDiscussionsInput {
  create?: GroupCreateWithoutDiscussionsInput | null
  connect?: GroupWhereUniqueInput | null
}
export type GroupCreateOneWithoutDiscussionsInputInputObject =
  | Extract<keyof GroupCreateOneWithoutDiscussionsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface GroupCreateWithoutDiscussionsInput {
  id?: string | null
  guid?: string
  members?: UserCreateManyWithoutGroupsJoinedInput | null
  name?: string
  isPublic?: boolean
}
export type GroupCreateWithoutDiscussionsInputInputObject =
  | Extract<keyof GroupCreateWithoutDiscussionsInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'members', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  
export interface UserCreateManyWithoutGroupsJoinedInput {
  create?: UserCreateWithoutGroupsJoinedInput[]
  connect?: UserWhereUniqueInput[]
}
export type UserCreateManyWithoutGroupsJoinedInputInputObject =
  | Extract<keyof UserCreateManyWithoutGroupsJoinedInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserCreateWithoutGroupsJoinedInput {
  id?: string | null
  guid?: string
  email?: string
  authorOf?: DiscussionCreateManyWithoutAuthorInput | null
}
export type UserCreateWithoutGroupsJoinedInputInputObject =
  | Extract<keyof UserCreateWithoutGroupsJoinedInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'authorOf', alias?: string  } 
  
export interface UserUpdateInput {
  guid?: string | null
  email?: string | null
  groupsJoined?: GroupUpdateManyWithoutMembersInput | null
  authorOf?: DiscussionUpdateManyWithoutAuthorInput | null
}
export type UserUpdateInputInputObject =
  | Extract<keyof UserUpdateInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'groupsJoined', alias?: string  } 
  | { name: 'authorOf', alias?: string  } 
  
export interface GroupUpdateManyWithoutMembersInput {
  create?: GroupCreateWithoutMembersInput[]
  delete?: GroupWhereUniqueInput[]
  connect?: GroupWhereUniqueInput[]
  set?: GroupWhereUniqueInput[]
  disconnect?: GroupWhereUniqueInput[]
  update?: GroupUpdateWithWhereUniqueWithoutMembersInput[]
  upsert?: GroupUpsertWithWhereUniqueWithoutMembersInput[]
  deleteMany?: GroupScalarWhereInput[]
  updateMany?: GroupUpdateManyWithWhereNestedInput[]
}
export type GroupUpdateManyWithoutMembersInputInputObject =
  | Extract<keyof GroupUpdateManyWithoutMembersInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface GroupUpdateWithWhereUniqueWithoutMembersInput {
  where?: GroupWhereUniqueInput
  data?: GroupUpdateWithoutMembersDataInput
}
export type GroupUpdateWithWhereUniqueWithoutMembersInputInputObject =
  | Extract<keyof GroupUpdateWithWhereUniqueWithoutMembersInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface GroupUpdateWithoutMembersDataInput {
  guid?: string | null
  discussions?: DiscussionUpdateManyWithoutGroupInput | null
  name?: string | null
  isPublic?: boolean | null
}
export type GroupUpdateWithoutMembersDataInputInputObject =
  | Extract<keyof GroupUpdateWithoutMembersDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'discussions', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  
export interface DiscussionUpdateManyWithoutGroupInput {
  create?: DiscussionCreateWithoutGroupInput[]
  delete?: DiscussionWhereUniqueInput[]
  connect?: DiscussionWhereUniqueInput[]
  set?: DiscussionWhereUniqueInput[]
  disconnect?: DiscussionWhereUniqueInput[]
  update?: DiscussionUpdateWithWhereUniqueWithoutGroupInput[]
  upsert?: DiscussionUpsertWithWhereUniqueWithoutGroupInput[]
  deleteMany?: DiscussionScalarWhereInput[]
  updateMany?: DiscussionUpdateManyWithWhereNestedInput[]
}
export type DiscussionUpdateManyWithoutGroupInputInputObject =
  | Extract<keyof DiscussionUpdateManyWithoutGroupInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface DiscussionUpdateWithWhereUniqueWithoutGroupInput {
  where?: DiscussionWhereUniqueInput
  data?: DiscussionUpdateWithoutGroupDataInput
}
export type DiscussionUpdateWithWhereUniqueWithoutGroupInputInputObject =
  | Extract<keyof DiscussionUpdateWithWhereUniqueWithoutGroupInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface DiscussionUpdateWithoutGroupDataInput {
  guid?: string | null
  author?: UserUpdateOneRequiredWithoutAuthorOfInput | null
  comments?: CommentUpdateManyInput | null
  title?: string | null
  content?: string | null
}
export type DiscussionUpdateWithoutGroupDataInputInputObject =
  | Extract<keyof DiscussionUpdateWithoutGroupDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface UserUpdateOneRequiredWithoutAuthorOfInput {
  create?: UserCreateWithoutAuthorOfInput | null
  update?: UserUpdateWithoutAuthorOfDataInput | null
  upsert?: UserUpsertWithoutAuthorOfInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserUpdateOneRequiredWithoutAuthorOfInputInputObject =
  | Extract<keyof UserUpdateOneRequiredWithoutAuthorOfInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserUpdateWithoutAuthorOfDataInput {
  guid?: string | null
  email?: string | null
  groupsJoined?: GroupUpdateManyWithoutMembersInput | null
}
export type UserUpdateWithoutAuthorOfDataInputInputObject =
  | Extract<keyof UserUpdateWithoutAuthorOfDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'groupsJoined', alias?: string  } 
  
export interface UserUpsertWithoutAuthorOfInput {
  update?: UserUpdateWithoutAuthorOfDataInput
  create?: UserCreateWithoutAuthorOfInput
}
export type UserUpsertWithoutAuthorOfInputInputObject =
  | Extract<keyof UserUpsertWithoutAuthorOfInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CommentUpdateManyInput {
  create?: CommentCreateInput[]
  update?: CommentUpdateWithWhereUniqueNestedInput[]
  upsert?: CommentUpsertWithWhereUniqueNestedInput[]
  delete?: CommentWhereUniqueInput[]
  connect?: CommentWhereUniqueInput[]
  set?: CommentWhereUniqueInput[]
  disconnect?: CommentWhereUniqueInput[]
  deleteMany?: CommentScalarWhereInput[]
  updateMany?: CommentUpdateManyWithWhereNestedInput[]
}
export type CommentUpdateManyInputInputObject =
  | Extract<keyof CommentUpdateManyInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface CommentUpdateWithWhereUniqueNestedInput {
  where?: CommentWhereUniqueInput
  data?: CommentUpdateDataInput
}
export type CommentUpdateWithWhereUniqueNestedInputInputObject =
  | Extract<keyof CommentUpdateWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface CommentUpdateDataInput {
  guid?: string | null
  author?: UserUpdateOneRequiredInput | null
  parentComment?: CommentUpdateOneInput | null
  content?: string | null
}
export type CommentUpdateDataInputInputObject =
  | Extract<keyof CommentUpdateDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'parentComment', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput | null
  update?: UserUpdateDataInput | null
  upsert?: UserUpsertNestedInput | null
  connect?: UserWhereUniqueInput | null
}
export type UserUpdateOneRequiredInputInputObject =
  | Extract<keyof UserUpdateOneRequiredInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface UserUpdateDataInput {
  guid?: string | null
  email?: string | null
  groupsJoined?: GroupUpdateManyWithoutMembersInput | null
  authorOf?: DiscussionUpdateManyWithoutAuthorInput | null
}
export type UserUpdateDataInputInputObject =
  | Extract<keyof UserUpdateDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'groupsJoined', alias?: string  } 
  | { name: 'authorOf', alias?: string  } 
  
export interface DiscussionUpdateManyWithoutAuthorInput {
  create?: DiscussionCreateWithoutAuthorInput[]
  delete?: DiscussionWhereUniqueInput[]
  connect?: DiscussionWhereUniqueInput[]
  set?: DiscussionWhereUniqueInput[]
  disconnect?: DiscussionWhereUniqueInput[]
  update?: DiscussionUpdateWithWhereUniqueWithoutAuthorInput[]
  upsert?: DiscussionUpsertWithWhereUniqueWithoutAuthorInput[]
  deleteMany?: DiscussionScalarWhereInput[]
  updateMany?: DiscussionUpdateManyWithWhereNestedInput[]
}
export type DiscussionUpdateManyWithoutAuthorInputInputObject =
  | Extract<keyof DiscussionUpdateManyWithoutAuthorInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface DiscussionUpdateWithWhereUniqueWithoutAuthorInput {
  where?: DiscussionWhereUniqueInput
  data?: DiscussionUpdateWithoutAuthorDataInput
}
export type DiscussionUpdateWithWhereUniqueWithoutAuthorInputInputObject =
  | Extract<keyof DiscussionUpdateWithWhereUniqueWithoutAuthorInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface DiscussionUpdateWithoutAuthorDataInput {
  guid?: string | null
  group?: GroupUpdateOneRequiredWithoutDiscussionsInput | null
  comments?: CommentUpdateManyInput | null
  title?: string | null
  content?: string | null
}
export type DiscussionUpdateWithoutAuthorDataInputInputObject =
  | Extract<keyof DiscussionUpdateWithoutAuthorDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'group', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface GroupUpdateOneRequiredWithoutDiscussionsInput {
  create?: GroupCreateWithoutDiscussionsInput | null
  update?: GroupUpdateWithoutDiscussionsDataInput | null
  upsert?: GroupUpsertWithoutDiscussionsInput | null
  connect?: GroupWhereUniqueInput | null
}
export type GroupUpdateOneRequiredWithoutDiscussionsInputInputObject =
  | Extract<keyof GroupUpdateOneRequiredWithoutDiscussionsInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface GroupUpdateWithoutDiscussionsDataInput {
  guid?: string | null
  members?: UserUpdateManyWithoutGroupsJoinedInput | null
  name?: string | null
  isPublic?: boolean | null
}
export type GroupUpdateWithoutDiscussionsDataInputInputObject =
  | Extract<keyof GroupUpdateWithoutDiscussionsDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'members', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  
export interface UserUpdateManyWithoutGroupsJoinedInput {
  create?: UserCreateWithoutGroupsJoinedInput[]
  delete?: UserWhereUniqueInput[]
  connect?: UserWhereUniqueInput[]
  set?: UserWhereUniqueInput[]
  disconnect?: UserWhereUniqueInput[]
  update?: UserUpdateWithWhereUniqueWithoutGroupsJoinedInput[]
  upsert?: UserUpsertWithWhereUniqueWithoutGroupsJoinedInput[]
  deleteMany?: UserScalarWhereInput[]
  updateMany?: UserUpdateManyWithWhereNestedInput[]
}
export type UserUpdateManyWithoutGroupsJoinedInputInputObject =
  | Extract<keyof UserUpdateManyWithoutGroupsJoinedInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  | { name: 'set', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'deleteMany', alias?: string  } 
  | { name: 'updateMany', alias?: string  } 
  
export interface UserUpdateWithWhereUniqueWithoutGroupsJoinedInput {
  where?: UserWhereUniqueInput
  data?: UserUpdateWithoutGroupsJoinedDataInput
}
export type UserUpdateWithWhereUniqueWithoutGroupsJoinedInputInputObject =
  | Extract<keyof UserUpdateWithWhereUniqueWithoutGroupsJoinedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface UserUpdateWithoutGroupsJoinedDataInput {
  guid?: string | null
  email?: string | null
  authorOf?: DiscussionUpdateManyWithoutAuthorInput | null
}
export type UserUpdateWithoutGroupsJoinedDataInputInputObject =
  | Extract<keyof UserUpdateWithoutGroupsJoinedDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'authorOf', alias?: string  } 
  
export interface UserUpsertWithWhereUniqueWithoutGroupsJoinedInput {
  where?: UserWhereUniqueInput
  update?: UserUpdateWithoutGroupsJoinedDataInput
  create?: UserCreateWithoutGroupsJoinedInput
}
export type UserUpsertWithWhereUniqueWithoutGroupsJoinedInputInputObject =
  | Extract<keyof UserUpsertWithWhereUniqueWithoutGroupsJoinedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface UserScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  guid?: string | null
  guid_not?: string | null
  guid_in?: string[]
  guid_not_in?: string[]
  guid_lt?: string | null
  guid_lte?: string | null
  guid_gt?: string | null
  guid_gte?: string | null
  guid_contains?: string | null
  guid_not_contains?: string | null
  guid_starts_with?: string | null
  guid_not_starts_with?: string | null
  guid_ends_with?: string | null
  guid_not_ends_with?: string | null
  email?: string | null
  email_not?: string | null
  email_in?: string[]
  email_not_in?: string[]
  email_lt?: string | null
  email_lte?: string | null
  email_gt?: string | null
  email_gte?: string | null
  email_contains?: string | null
  email_not_contains?: string | null
  email_starts_with?: string | null
  email_not_starts_with?: string | null
  email_ends_with?: string | null
  email_not_ends_with?: string | null
  AND?: UserScalarWhereInput[]
  OR?: UserScalarWhereInput[]
  NOT?: UserScalarWhereInput[]
}
export type UserScalarWhereInputInputObject =
  | Extract<keyof UserScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'guid_not', alias?: string  } 
  | { name: 'guid_in', alias?: string  } 
  | { name: 'guid_not_in', alias?: string  } 
  | { name: 'guid_lt', alias?: string  } 
  | { name: 'guid_lte', alias?: string  } 
  | { name: 'guid_gt', alias?: string  } 
  | { name: 'guid_gte', alias?: string  } 
  | { name: 'guid_contains', alias?: string  } 
  | { name: 'guid_not_contains', alias?: string  } 
  | { name: 'guid_starts_with', alias?: string  } 
  | { name: 'guid_not_starts_with', alias?: string  } 
  | { name: 'guid_ends_with', alias?: string  } 
  | { name: 'guid_not_ends_with', alias?: string  } 
  | { name: 'email', alias?: string  } 
  | { name: 'email_not', alias?: string  } 
  | { name: 'email_in', alias?: string  } 
  | { name: 'email_not_in', alias?: string  } 
  | { name: 'email_lt', alias?: string  } 
  | { name: 'email_lte', alias?: string  } 
  | { name: 'email_gt', alias?: string  } 
  | { name: 'email_gte', alias?: string  } 
  | { name: 'email_contains', alias?: string  } 
  | { name: 'email_not_contains', alias?: string  } 
  | { name: 'email_starts_with', alias?: string  } 
  | { name: 'email_not_starts_with', alias?: string  } 
  | { name: 'email_ends_with', alias?: string  } 
  | { name: 'email_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface UserUpdateManyWithWhereNestedInput {
  where?: UserScalarWhereInput
  data?: UserUpdateManyDataInput
}
export type UserUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof UserUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface UserUpdateManyDataInput {
  guid?: string | null
  email?: string | null
}
export type UserUpdateManyDataInputInputObject =
  | Extract<keyof UserUpdateManyDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  
export interface GroupUpsertWithoutDiscussionsInput {
  update?: GroupUpdateWithoutDiscussionsDataInput
  create?: GroupCreateWithoutDiscussionsInput
}
export type GroupUpsertWithoutDiscussionsInputInputObject =
  | Extract<keyof GroupUpsertWithoutDiscussionsInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface DiscussionUpsertWithWhereUniqueWithoutAuthorInput {
  where?: DiscussionWhereUniqueInput
  update?: DiscussionUpdateWithoutAuthorDataInput
  create?: DiscussionCreateWithoutAuthorInput
}
export type DiscussionUpsertWithWhereUniqueWithoutAuthorInputInputObject =
  | Extract<keyof DiscussionUpsertWithWhereUniqueWithoutAuthorInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface DiscussionScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  guid?: string | null
  guid_not?: string | null
  guid_in?: string[]
  guid_not_in?: string[]
  guid_lt?: string | null
  guid_lte?: string | null
  guid_gt?: string | null
  guid_gte?: string | null
  guid_contains?: string | null
  guid_not_contains?: string | null
  guid_starts_with?: string | null
  guid_not_starts_with?: string | null
  guid_ends_with?: string | null
  guid_not_ends_with?: string | null
  title?: string | null
  title_not?: string | null
  title_in?: string[]
  title_not_in?: string[]
  title_lt?: string | null
  title_lte?: string | null
  title_gt?: string | null
  title_gte?: string | null
  title_contains?: string | null
  title_not_contains?: string | null
  title_starts_with?: string | null
  title_not_starts_with?: string | null
  title_ends_with?: string | null
  title_not_ends_with?: string | null
  content?: string | null
  content_not?: string | null
  content_in?: string[]
  content_not_in?: string[]
  content_lt?: string | null
  content_lte?: string | null
  content_gt?: string | null
  content_gte?: string | null
  content_contains?: string | null
  content_not_contains?: string | null
  content_starts_with?: string | null
  content_not_starts_with?: string | null
  content_ends_with?: string | null
  content_not_ends_with?: string | null
  AND?: DiscussionScalarWhereInput[]
  OR?: DiscussionScalarWhereInput[]
  NOT?: DiscussionScalarWhereInput[]
}
export type DiscussionScalarWhereInputInputObject =
  | Extract<keyof DiscussionScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'guid_not', alias?: string  } 
  | { name: 'guid_in', alias?: string  } 
  | { name: 'guid_not_in', alias?: string  } 
  | { name: 'guid_lt', alias?: string  } 
  | { name: 'guid_lte', alias?: string  } 
  | { name: 'guid_gt', alias?: string  } 
  | { name: 'guid_gte', alias?: string  } 
  | { name: 'guid_contains', alias?: string  } 
  | { name: 'guid_not_contains', alias?: string  } 
  | { name: 'guid_starts_with', alias?: string  } 
  | { name: 'guid_not_starts_with', alias?: string  } 
  | { name: 'guid_ends_with', alias?: string  } 
  | { name: 'guid_not_ends_with', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'title_not', alias?: string  } 
  | { name: 'title_in', alias?: string  } 
  | { name: 'title_not_in', alias?: string  } 
  | { name: 'title_lt', alias?: string  } 
  | { name: 'title_lte', alias?: string  } 
  | { name: 'title_gt', alias?: string  } 
  | { name: 'title_gte', alias?: string  } 
  | { name: 'title_contains', alias?: string  } 
  | { name: 'title_not_contains', alias?: string  } 
  | { name: 'title_starts_with', alias?: string  } 
  | { name: 'title_not_starts_with', alias?: string  } 
  | { name: 'title_ends_with', alias?: string  } 
  | { name: 'title_not_ends_with', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'content_not', alias?: string  } 
  | { name: 'content_in', alias?: string  } 
  | { name: 'content_not_in', alias?: string  } 
  | { name: 'content_lt', alias?: string  } 
  | { name: 'content_lte', alias?: string  } 
  | { name: 'content_gt', alias?: string  } 
  | { name: 'content_gte', alias?: string  } 
  | { name: 'content_contains', alias?: string  } 
  | { name: 'content_not_contains', alias?: string  } 
  | { name: 'content_starts_with', alias?: string  } 
  | { name: 'content_not_starts_with', alias?: string  } 
  | { name: 'content_ends_with', alias?: string  } 
  | { name: 'content_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface DiscussionUpdateManyWithWhereNestedInput {
  where?: DiscussionScalarWhereInput
  data?: DiscussionUpdateManyDataInput
}
export type DiscussionUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof DiscussionUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface DiscussionUpdateManyDataInput {
  guid?: string | null
  title?: string | null
  content?: string | null
}
export type DiscussionUpdateManyDataInputInputObject =
  | Extract<keyof DiscussionUpdateManyDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface UserUpsertNestedInput {
  update?: UserUpdateDataInput
  create?: UserCreateInput
}
export type UserUpsertNestedInputInputObject =
  | Extract<keyof UserUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CommentUpdateOneInput {
  create?: CommentCreateInput | null
  update?: CommentUpdateDataInput | null
  upsert?: CommentUpsertNestedInput | null
  delete?: boolean | null
  disconnect?: boolean | null
  connect?: CommentWhereUniqueInput | null
}
export type CommentUpdateOneInputInputObject =
  | Extract<keyof CommentUpdateOneInput, string>
  | { name: 'create', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'upsert', alias?: string  } 
  | { name: 'delete', alias?: string  } 
  | { name: 'disconnect', alias?: string  } 
  | { name: 'connect', alias?: string  } 
  
export interface CommentUpsertNestedInput {
  update?: CommentUpdateDataInput
  create?: CommentCreateInput
}
export type CommentUpsertNestedInputInputObject =
  | Extract<keyof CommentUpsertNestedInput, string>
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CommentUpsertWithWhereUniqueNestedInput {
  where?: CommentWhereUniqueInput
  update?: CommentUpdateDataInput
  create?: CommentCreateInput
}
export type CommentUpsertWithWhereUniqueNestedInputInputObject =
  | Extract<keyof CommentUpsertWithWhereUniqueNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface CommentScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  guid?: string | null
  guid_not?: string | null
  guid_in?: string[]
  guid_not_in?: string[]
  guid_lt?: string | null
  guid_lte?: string | null
  guid_gt?: string | null
  guid_gte?: string | null
  guid_contains?: string | null
  guid_not_contains?: string | null
  guid_starts_with?: string | null
  guid_not_starts_with?: string | null
  guid_ends_with?: string | null
  guid_not_ends_with?: string | null
  content?: string | null
  content_not?: string | null
  content_in?: string[]
  content_not_in?: string[]
  content_lt?: string | null
  content_lte?: string | null
  content_gt?: string | null
  content_gte?: string | null
  content_contains?: string | null
  content_not_contains?: string | null
  content_starts_with?: string | null
  content_not_starts_with?: string | null
  content_ends_with?: string | null
  content_not_ends_with?: string | null
  AND?: CommentScalarWhereInput[]
  OR?: CommentScalarWhereInput[]
  NOT?: CommentScalarWhereInput[]
}
export type CommentScalarWhereInputInputObject =
  | Extract<keyof CommentScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'guid_not', alias?: string  } 
  | { name: 'guid_in', alias?: string  } 
  | { name: 'guid_not_in', alias?: string  } 
  | { name: 'guid_lt', alias?: string  } 
  | { name: 'guid_lte', alias?: string  } 
  | { name: 'guid_gt', alias?: string  } 
  | { name: 'guid_gte', alias?: string  } 
  | { name: 'guid_contains', alias?: string  } 
  | { name: 'guid_not_contains', alias?: string  } 
  | { name: 'guid_starts_with', alias?: string  } 
  | { name: 'guid_not_starts_with', alias?: string  } 
  | { name: 'guid_ends_with', alias?: string  } 
  | { name: 'guid_not_ends_with', alias?: string  } 
  | { name: 'content', alias?: string  } 
  | { name: 'content_not', alias?: string  } 
  | { name: 'content_in', alias?: string  } 
  | { name: 'content_not_in', alias?: string  } 
  | { name: 'content_lt', alias?: string  } 
  | { name: 'content_lte', alias?: string  } 
  | { name: 'content_gt', alias?: string  } 
  | { name: 'content_gte', alias?: string  } 
  | { name: 'content_contains', alias?: string  } 
  | { name: 'content_not_contains', alias?: string  } 
  | { name: 'content_starts_with', alias?: string  } 
  | { name: 'content_not_starts_with', alias?: string  } 
  | { name: 'content_ends_with', alias?: string  } 
  | { name: 'content_not_ends_with', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CommentUpdateManyWithWhereNestedInput {
  where?: CommentScalarWhereInput
  data?: CommentUpdateManyDataInput
}
export type CommentUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof CommentUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface CommentUpdateManyDataInput {
  guid?: string | null
  content?: string | null
}
export type CommentUpdateManyDataInputInputObject =
  | Extract<keyof CommentUpdateManyDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface DiscussionUpsertWithWhereUniqueWithoutGroupInput {
  where?: DiscussionWhereUniqueInput
  update?: DiscussionUpdateWithoutGroupDataInput
  create?: DiscussionCreateWithoutGroupInput
}
export type DiscussionUpsertWithWhereUniqueWithoutGroupInputInputObject =
  | Extract<keyof DiscussionUpsertWithWhereUniqueWithoutGroupInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface GroupUpsertWithWhereUniqueWithoutMembersInput {
  where?: GroupWhereUniqueInput
  update?: GroupUpdateWithoutMembersDataInput
  create?: GroupCreateWithoutMembersInput
}
export type GroupUpsertWithWhereUniqueWithoutMembersInputInputObject =
  | Extract<keyof GroupUpsertWithWhereUniqueWithoutMembersInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'update', alias?: string  } 
  | { name: 'create', alias?: string  } 
  
export interface GroupScalarWhereInput {
  id?: string | null
  id_not?: string | null
  id_in?: string[]
  id_not_in?: string[]
  id_lt?: string | null
  id_lte?: string | null
  id_gt?: string | null
  id_gte?: string | null
  id_contains?: string | null
  id_not_contains?: string | null
  id_starts_with?: string | null
  id_not_starts_with?: string | null
  id_ends_with?: string | null
  id_not_ends_with?: string | null
  guid?: string | null
  guid_not?: string | null
  guid_in?: string[]
  guid_not_in?: string[]
  guid_lt?: string | null
  guid_lte?: string | null
  guid_gt?: string | null
  guid_gte?: string | null
  guid_contains?: string | null
  guid_not_contains?: string | null
  guid_starts_with?: string | null
  guid_not_starts_with?: string | null
  guid_ends_with?: string | null
  guid_not_ends_with?: string | null
  name?: string | null
  name_not?: string | null
  name_in?: string[]
  name_not_in?: string[]
  name_lt?: string | null
  name_lte?: string | null
  name_gt?: string | null
  name_gte?: string | null
  name_contains?: string | null
  name_not_contains?: string | null
  name_starts_with?: string | null
  name_not_starts_with?: string | null
  name_ends_with?: string | null
  name_not_ends_with?: string | null
  isPublic?: boolean | null
  isPublic_not?: boolean | null
  AND?: GroupScalarWhereInput[]
  OR?: GroupScalarWhereInput[]
  NOT?: GroupScalarWhereInput[]
}
export type GroupScalarWhereInputInputObject =
  | Extract<keyof GroupScalarWhereInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'id_not', alias?: string  } 
  | { name: 'id_in', alias?: string  } 
  | { name: 'id_not_in', alias?: string  } 
  | { name: 'id_lt', alias?: string  } 
  | { name: 'id_lte', alias?: string  } 
  | { name: 'id_gt', alias?: string  } 
  | { name: 'id_gte', alias?: string  } 
  | { name: 'id_contains', alias?: string  } 
  | { name: 'id_not_contains', alias?: string  } 
  | { name: 'id_starts_with', alias?: string  } 
  | { name: 'id_not_starts_with', alias?: string  } 
  | { name: 'id_ends_with', alias?: string  } 
  | { name: 'id_not_ends_with', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'guid_not', alias?: string  } 
  | { name: 'guid_in', alias?: string  } 
  | { name: 'guid_not_in', alias?: string  } 
  | { name: 'guid_lt', alias?: string  } 
  | { name: 'guid_lte', alias?: string  } 
  | { name: 'guid_gt', alias?: string  } 
  | { name: 'guid_gte', alias?: string  } 
  | { name: 'guid_contains', alias?: string  } 
  | { name: 'guid_not_contains', alias?: string  } 
  | { name: 'guid_starts_with', alias?: string  } 
  | { name: 'guid_not_starts_with', alias?: string  } 
  | { name: 'guid_ends_with', alias?: string  } 
  | { name: 'guid_not_ends_with', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'name_not', alias?: string  } 
  | { name: 'name_in', alias?: string  } 
  | { name: 'name_not_in', alias?: string  } 
  | { name: 'name_lt', alias?: string  } 
  | { name: 'name_lte', alias?: string  } 
  | { name: 'name_gt', alias?: string  } 
  | { name: 'name_gte', alias?: string  } 
  | { name: 'name_contains', alias?: string  } 
  | { name: 'name_not_contains', alias?: string  } 
  | { name: 'name_starts_with', alias?: string  } 
  | { name: 'name_not_starts_with', alias?: string  } 
  | { name: 'name_ends_with', alias?: string  } 
  | { name: 'name_not_ends_with', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  | { name: 'isPublic_not', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface GroupUpdateManyWithWhereNestedInput {
  where?: GroupScalarWhereInput
  data?: GroupUpdateManyDataInput
}
export type GroupUpdateManyWithWhereNestedInputInputObject =
  | Extract<keyof GroupUpdateManyWithWhereNestedInput, string>
  | { name: 'where', alias?: string  } 
  | { name: 'data', alias?: string  } 
  
export interface GroupUpdateManyDataInput {
  guid?: string | null
  name?: string | null
  isPublic?: boolean | null
}
export type GroupUpdateManyDataInputInputObject =
  | Extract<keyof GroupUpdateManyDataInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  
export interface UserUpdateManyMutationInput {
  guid?: string | null
  email?: string | null
}
export type UserUpdateManyMutationInputInputObject =
  | Extract<keyof UserUpdateManyMutationInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'email', alias?: string  } 
  
export interface GroupCreateInput {
  id?: string | null
  guid?: string
  members?: UserCreateManyWithoutGroupsJoinedInput | null
  discussions?: DiscussionCreateManyWithoutGroupInput | null
  name?: string
  isPublic?: boolean
}
export type GroupCreateInputInputObject =
  | Extract<keyof GroupCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'members', alias?: string  } 
  | { name: 'discussions', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  
export interface GroupUpdateInput {
  guid?: string | null
  members?: UserUpdateManyWithoutGroupsJoinedInput | null
  discussions?: DiscussionUpdateManyWithoutGroupInput | null
  name?: string | null
  isPublic?: boolean | null
}
export type GroupUpdateInputInputObject =
  | Extract<keyof GroupUpdateInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'members', alias?: string  } 
  | { name: 'discussions', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  
export interface GroupUpdateManyMutationInput {
  guid?: string | null
  name?: string | null
  isPublic?: boolean | null
}
export type GroupUpdateManyMutationInputInputObject =
  | Extract<keyof GroupUpdateManyMutationInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'name', alias?: string  } 
  | { name: 'isPublic', alias?: string  } 
  
export interface DiscussionCreateInput {
  id?: string | null
  guid?: string
  author?: UserCreateOneWithoutAuthorOfInput
  group?: GroupCreateOneWithoutDiscussionsInput
  comments?: CommentCreateManyInput | null
  title?: string
  content?: string
}
export type DiscussionCreateInputInputObject =
  | Extract<keyof DiscussionCreateInput, string>
  | { name: 'id', alias?: string  } 
  | { name: 'guid', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'group', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface DiscussionUpdateInput {
  guid?: string | null
  author?: UserUpdateOneRequiredWithoutAuthorOfInput | null
  group?: GroupUpdateOneRequiredWithoutDiscussionsInput | null
  comments?: CommentUpdateManyInput | null
  title?: string | null
  content?: string | null
}
export type DiscussionUpdateInputInputObject =
  | Extract<keyof DiscussionUpdateInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'group', alias?: string  } 
  | { name: 'comments', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface DiscussionUpdateManyMutationInput {
  guid?: string | null
  title?: string | null
  content?: string | null
}
export type DiscussionUpdateManyMutationInputInputObject =
  | Extract<keyof DiscussionUpdateManyMutationInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'title', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface CommentUpdateInput {
  guid?: string | null
  author?: UserUpdateOneRequiredInput | null
  parentComment?: CommentUpdateOneInput | null
  content?: string | null
}
export type CommentUpdateInputInputObject =
  | Extract<keyof CommentUpdateInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'author', alias?: string  } 
  | { name: 'parentComment', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface CommentUpdateManyMutationInput {
  guid?: string | null
  content?: string | null
}
export type CommentUpdateManyMutationInputInputObject =
  | Extract<keyof CommentUpdateManyMutationInput, string>
  | { name: 'guid', alias?: string  } 
  | { name: 'content', alias?: string  } 
  
export interface UserSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: UserWhereInput | null
  AND?: UserSubscriptionWhereInput[]
  OR?: UserSubscriptionWhereInput[]
  NOT?: UserSubscriptionWhereInput[]
}
export type UserSubscriptionWhereInputInputObject =
  | Extract<keyof UserSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface GroupSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: GroupWhereInput | null
  AND?: GroupSubscriptionWhereInput[]
  OR?: GroupSubscriptionWhereInput[]
  NOT?: GroupSubscriptionWhereInput[]
}
export type GroupSubscriptionWhereInputInputObject =
  | Extract<keyof GroupSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface DiscussionSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: DiscussionWhereInput | null
  AND?: DiscussionSubscriptionWhereInput[]
  OR?: DiscussionSubscriptionWhereInput[]
  NOT?: DiscussionSubscriptionWhereInput[]
}
export type DiscussionSubscriptionWhereInputInputObject =
  | Extract<keyof DiscussionSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  
export interface CommentSubscriptionWhereInput {
  mutation_in?: prisma.MutationType[]
  updatedFields_contains?: string | null
  updatedFields_contains_every?: string[]
  updatedFields_contains_some?: string[]
  node?: CommentWhereInput | null
  AND?: CommentSubscriptionWhereInput[]
  OR?: CommentSubscriptionWhereInput[]
  NOT?: CommentSubscriptionWhereInput[]
}
export type CommentSubscriptionWhereInputInputObject =
  | Extract<keyof CommentSubscriptionWhereInput, string>
  | { name: 'mutation_in', alias?: string  } 
  | { name: 'updatedFields_contains', alias?: string  } 
  | { name: 'updatedFields_contains_every', alias?: string  } 
  | { name: 'updatedFields_contains_some', alias?: string  } 
  | { name: 'node', alias?: string  } 
  | { name: 'AND', alias?: string  } 
  | { name: 'OR', alias?: string  } 
  | { name: 'NOT', alias?: string  } 
  

export type GroupOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'guid_ASC'
  | 'guid_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'isPublic_ASC'
  | 'isPublic_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type UserOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'guid_ASC'
  | 'guid_DESC'
  | 'email_ASC'
  | 'email_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type DiscussionOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'guid_ASC'
  | 'guid_DESC'
  | 'title_ASC'
  | 'title_DESC'
  | 'content_ASC'
  | 'content_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type CommentOrderByInputValues =
  | 'id_ASC'
  | 'id_DESC'
  | 'guid_ASC'
  | 'guid_DESC'
  | 'content_ASC'
  | 'content_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  
export type MutationTypeValues =
  | 'CREATED'
  | 'UPDATED'
  | 'DELETED'
  
  